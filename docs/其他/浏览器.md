# 浏览器

## 浏览器渲染原理

浏览器的渲染是从接收到服务器响应的资源开始处理的，以下面的代码为例，从浏览器接收到资源（html文件）到屏幕显示出来一个带有 h1 样式的 hello world，这里面浏览器所做的处理其实就是渲染。

```html
<!-- ... -->
<h1>hello world</h1>
<!-- ... -->
```

整个渲染的流程包括了：html 解析、样式计算、布局、分层、绘制、合成（分块、光栅化、画）

### HTML 解析

简单来说就是，HTML 字符串经过处理，可以被处理成 DOM 树和 CSSOM 树，浏览器提供给 JS 操作这两棵树的能力。

HTML 具体被编译成 DOM 树，最开始会先对 HTML 代码做词法分析，分成多个 token（标记），根据这些 token 去构造出一棵 DOM 树。

**没去了解过浏览器是怎么具体对 HTML 做词法分析的，但是我在 Vue.js 设计与实现中看到过 Vue 的解析器是怎么将模版语法解析成虚拟 DOM，我觉得应该是类似的**

其实，其中用到了一个叫状态机的算法，其实是一种状态模式的体现，在这种模式下，会自动切换满足不同条件的不同的状态，只能指定初始态，对于状态机运行过程中，外部无法再指定状态。

简单讲下状态机是怎么对模版语法进行语法分析并分析出多个 token 的，以上面 hello world 的代码为例：

最开始的状态机会是一个初始状态，然后输入一串字符串 `<h1>hello world</h1>`，对每个字符做处理，当遇到 `<` 时做xxx操作，当已经遇到 `<` 之后又遇到字母做xxx操作，当遇到 `>` 做xxx操作，简单来说就是状态的切换配合一些特定的操作，可以去看《Vue.js 设计与实现》里面讲得很详细。

当然，在解析 HTML 代码的过程中，也会遇到 CSS 和 JS，对于两种情况也有不一样的处理：

- CSS：

  一般主线程在解析 HTML 代码时，解析到 `link` 标签的话，如果此时外部 CSS 文件还没下载解析好，主线程不会等待，而会继续解析后续的 HTML 代码。因为下载和解析 CSS 是在预解析线程中进行的，在解析完之后，会把结果（CSSOM 树）返回给主线程。

  ![](image/image_cssom.png)

- JS：

  解析到 `script` 标签的时候，默认情况下，会停止解析 HTML 代码，等待 JS 文件下载，然后解析并执行代码，才会继续解析 HTML。
  因为 JS 拥有操作 DOM 的能力，所以 DOM 树的生成需要暂停。

  当然，`script` 标签里面有两个属性 `async` 和 `defer` 可以控制对应外部 JS 文件的执行时间，这两个属性都会使 JS 文件异步下载：
  - `async` 会在 JS 文件下载完成之后，停止解析 HTML 代码，马上解析执行 JS 代码
  - `defer` 则是 JS 文件下载完成之后，不立即执行，如果还有 HTML 代码未解析完成，会等待其解析完再解析执行 JS 代码

  ![](image/image_script.png)

### 样式计算

在经过第一步的 HTML 解析之后，得到了 DOM 树和 CSSOM 树，但是还需要知道每个 DOM 节点对应有哪些样式。
主线程会遍历 DOM 树中的所有 DOM 节点计算出最终的样式（computed style）。

![](image/image_computedstyle.png)

### 布局

在布局（Layout）阶段，主线程同样会遍历所有 DOM 节点，计算出 DOM 节点的几何属性（宽高、位置等等），从而得到一棵 Layout 树。

**DOM 树和 Layout 树不一定一一对应**

- 某些设置了 `display: none` 的节点，就不会生成到 Layout 树
- 使用了伪元素选择器，在 DOM 树中不存在这些伪元素节点的，但是拥有几何信息，所以会生成到 Layout 树中

![](image/image_display.png)

### 分层

主线程对 Layout 树进行分层。将来某一层的内容发生改变，就只需要改变那一层即可，提升更新效率。

滚动条、z-index、transform、opacity 这些样式都会影响分层结果。

### 绘制

为每一层单独产生绘制指令集，用于描述该层的内容是怎么画出来的

### 合成

- 分块

  在完成绘制之后，主线程将每个图层的绘制信息提交给合成线程，剩余的工作将会由合成线程来完成。合成线程会先对每个图层进行分块，将其划分为更多的区域。

  ![](image/image_tile.png)

- 光栅化
  
  将分好的块变成位图，其实就是转成一个二维矩阵，矩阵里面记录每个像素点的信息。会优先处理靠近视口的块。

  ![](image/image_transform.png)

- Draw
  
  合成线程在得到每个层、每个块的位图之后，生成多个指引信息（quad）。

  这些指引信息会标识出每个位图画到屏幕的哪个位置，结合旋转、缩放等变形操作。

  变形（transform）发生在合成线程，与渲染主线程无关，它跳过了布局、分层、绘制的流程，直接从合成这一 part 开始，这就是 transform 效率高的原因。


渲染的完整流程如下图所示：

![](image/image_render.png)

上述流程一通走下来其实非常繁琐，且耗费资源，所以作为前端开发者，在对页面进行更新的时候应该要考虑到，怎么用最小的资源做到最多的事

- 重排（回流）

  重排其实就是因为某些操作导致，浏览器需要 DOM 和 CSSOM 重新做样式计算，得到 Layout 树，然后一条龙渲染下来，整个流程走一遍，那么效率就会很低。

  导致重排的操作：
  1. 增删 DOM
  2. 修改几何样式
  3. 获取 DOM 的几何属性
  。。。

- 重绘

  重绘就是在重新渲染的过程中，跳过了布局、分层阶段，直接进入绘制阶段，相比重排，工作量更少，开销也会更低。
  比如修改颜色。

- 合成

  如果使用 CSS 的 transform 来实现动画效果，会跳过布局和绘制阶段，直接在非主线程进行合成动画。合成的效率比回流、重绘要高很多，因为合成是在非主线程进行合成，还跳过了布局和绘制阶段。


